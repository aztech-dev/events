{"name":"Events","tagline":"","body":"# aztech/events\r\n\r\n## Important notice\r\n\r\nThis package is the main repository for aztech/events, and does not contain any code. Please refer\r\nto the composer.json to view the list of the packages provided by this package.\r\n\r\n## Stability\r\n\r\n[![Latest Stable Version](https://poser.pugx.org/aztech/events/v/stable.png)](https://packagist.org/packages/aztech/events)\r\n[![Latest Unstable Version](https://poser.pugx.org/aztech/events/v/unstable.png)](https://packagist.org/packages/aztech/events)\r\n\r\n## Installation\r\n\r\n### Via Composer\r\n\r\nComposer is the only supported way of installing *aztech/events* . Don't know Composer yet ? [Read more about it](https://getcomposer.org/doc/00-intro.md).\r\n\r\n\r\n```bash\r\n$ composer require \"aztech/events\":\"~1\"\r\n```\r\n\r\n## Autoloading\r\n\r\nAdd the following code to your bootstrap file :\r\n\r\n```php\r\nrequire_once 'vendor/autoload.php';\r\n```\r\n\r\n## Concepts\r\n\r\n*aztech/events* aims to provide a solid foundation to build event driven architectures in PHP. \r\n\r\nThe current mainstream approach in existing libraries is currently to produce and consume events within the same process (for example, during a single HTTP request). While this is fine in most cases,\r\nit does not fit in well with distributed systems, where events need to cross process/host boundaries. This library attempts to solve that by decoupling totally the publish and the subscribe processes through the use of *event channels*. \r\n\r\nAn event channel is simply any resource to which data can be written to and retrieved later (read TCP socket, memory, shared memory, files, message queues...). When an event is published, it is serialized and written to a channel, instead of being dispatched to the event subscribers. \r\n\r\nOn the other end of the channel, a consumer is responsible for reading incoming events (synchronously or not, depending on the channel type used) and pushing them to a standard event dispatcher.\r\n\r\nThis means you can publish and dispatch events using the following methods :\r\n\r\n    * In process (tested)\r\n    * Out-of-process\r\n      * Database via PDO (untested)\r\n      * AMQP (tested)\r\n      * STOMP (untested)\r\n      * Wamp (publish only, partially tested)\r\n      * Redis (untested)\r\n      * Mixpanel (publish only, untested)\r\n      * File (tested)\r\n      * And more to come...\r\n    \r\n**TODO** : Test the untested transports\r\n\r\nIf you want to create and publish events, you will need to use a **publisher**. Currently, the library provides native support for publishing events to AMQP-compatible message queues and synchronous event publishing.\r\n\r\nIf you want to consume published events, you will need to use a **processor**. A processor is responsible for receiving events via whatever transport it uses. Currently, the library provides native support for consuming AMQP-compatible message queues and synchronous event consumption. The library provides hooks to which you can bind **subscribers**, which are simple event handlers.\r\n\r\nOptionally, the library provides an Application object to which you can easily bind subscribers.\r\n\r\n## Usage\r\n\r\nFor simplicity, there are factories available to create publishers and dispatchers.\r\n\r\nListed below are examples for some of the providers. The full documentation is available [here](./doc/plugins.md).\r\n\r\n### Basic usage\r\n\r\n```php\r\n\\Aztech\\Events\\Bus\\Plugins::loadMemoryPlugin();\r\n\r\n$publisher = \\Aztech\\Events\\Events::createPublisher('memory');\r\n$processor = \\Aztech\\Events\\Events::createProcessor('memory');\r\n\r\n// Subscribe to all events using a wildcard filter\r\n$processor->on('#', function (Event $event) {\r\n    echo 'Received a new event : ' . $event->getCategory();\r\n});\r\n\r\n$event = \\Aztech\\Events\\Events::create('category', array('property' => 'value'));\r\n$publisher->publish($event);\r\n```\r\n\r\nCheckout the provider specific documentations for more usage examples.\r\n\r\n## Event matching rules\r\n\r\n> **tl;dr** Use '#' to match absolutely anything, '*' to match exactly one unknown word.\r\n\r\nEvent category matching actually follows the [AMQP topic specification](https://svn.apache.org/repos/asf/qpid/trunk/qpid/specs/apache-filters.xml#section-legacy-amqp), which is quite flexible :\r\n\r\n> The legacy-amqp-topic-binding filter consists of a described string value. The value value described by the type is interpreted as a pattern to match against the subject field of the Properties section of the message being evaluated.\r\n>\r\n> The pattern is formed using zero or more tokens, with each token delimited by the \".\" character. The tokens \"#\" and \"\\*\" have special meanings.\r\n> The token consisting of the single character \"\\*\" matches a single word in the subject field.\r\n> The token consisting of the single character \"#\" matches zero or more words in the subject field.\r\n> Thus the filter value \"*.stock.#\" would match the subjects \"usd.stock\" and \"eur.stock.db\" but not \"stock.nasdaq\".\r\n\r\nBasically, a topic name must be composed of letters and/or numbers and dashes. Sub-topics can be \r\nspecified by using dots :\r\n\r\n```\r\ntopic\r\ntopic.subtopic\r\ntopic.subtopic.leaf\r\n```\r\nYou can use '*' as a wildcard to match exactly one component in a topic :\r\n\r\n```\r\ntopic.* will match with topic.subtopic, but not with topic nor topic.subtopic.leaf\r\n```\r\n\r\nThere is also '#', which means 0 or more components :\r\n```\r\n# will match all possible topics. \r\ntopic.# will match topic, topic.subtopic, and topic.subtopic.leaf and any subtopic of topic no matter its nesting level\r\ntopic.#.leaf will match topic.subtopic.leaf and topic.other.leaf and many others, but not topic.subtopic.other\r\n```\r\n\r\nTo get check the latest truth table of event matching, please refer to the source of `Aztech\\Events\\Tests\\Unit\\CategoryMatchTruthTable`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}